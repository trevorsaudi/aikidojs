import{bF as r,bG as I,aw as z,bH as L}from"./index-13ff96f4.js";function D(w,_,m=s=>s,b={}){const s=r(0),i=r([]),n=r(!1),h=r(!0),u=r(!0),g=r(void 0),y=r(!1),d=r(!0);let a=null,c=null;I(()=>{a&&a.disconnect()});const F=(e,v)=>{e&&(a&&a.disconnect(),c=e,a=new IntersectionObserver(async f=>{f.some(l=>l.isIntersecting)&&!u.value&&await o(g.value)},v),a.observe(e))},x=async()=>{!c||!a||(a.unobserve(c),a.observe(c))},p=z(e=>{d.value=e},250),o=async e=>{if(g.value=e,n.value===!0)return;h.value=!0,d.value=!0,p(!0);const v=s.value;s.value=s.value+1;let f=!1;try{const t=await w({...g.value,page:v,per_page:_}),l=m(t);v===0?(i.value=l,y.value=(t==null?void 0:t.fuzzy_search_used)||!1):i.value.push(...l),"might_have_next_page"in t?t.might_have_next_page===!0?n.value=!1:t.might_have_next_page===!1&&(n.value=!0):b&&b.stopPaginationBehaviour==="eager"?n.value=l.length<_:n.value=l.length===0}catch{f=!0}finally{h.value=!1,u.value=!1,p(!1),await L(),!f&&x()}};return{records:i,currentPage:s,hasFetchedAllRecords:n,isLoading:h,isLoadingFirstPage:u,isLoadingWithDebouncedFinish:d,fetch:o,reset:async e=>{s.value=0,i.value=[],n.value=!1,u.value=!0,await o(e)},refresh:async e=>{s.value=0,n.value=!1,u.value=!0,await o(e)},watchElement:F,isFuzzySearch:y}}export{D as u};
